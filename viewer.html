<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta name="robots" content="noindex, nofollow" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>STAT画像学習システム</title>
    <link href="css/viewer.css" rel="stylesheet" />
    
    <script>
      // 未認証ならログインへ
      if (sessionStorage.getItem("authenticated") !== "true") {
        location.replace("index.html");
      } 
    </script>
  </head>

  <body>
    <div id="loadingOverlay">
      <div class="spinner"></div>
      <div class="loading-text">Loading...</div>
    </div>

    <main style="display: none">
      <h1 id="setTitle">検査画像</h1>

      <div class="set-buttons" id="setButtonsContainer"></div>

      <!-- 画像ビューア -->
      <div class="viewer">
        <img alt="CT Slice" id="ctImage" src="" />

        <!-- 右下：全画面ボタン -->
        <button id="enterFsBtn" class="fullscreen-btn" aria-label="全画面表示">
            [ 全画面 ]
        </button>
      </div>

      <!--  ズーム -->
      <div class="zoom-controls" aria-label="ズーム操作">
        <button type="button" id="zoomOutBtn" class="zoom-button" aria-label="縮小">🔎－</button>
        <span id="zoomLevel" class="zoom-level" aria-live="polite" aria-atomic="true">100%</span>
        <button type="button" id="zoomInBtn" class="zoom-button" aria-label="拡大">🔎＋</button>
      </div>

      <!-- ▼ スライダー（通常表示） -->
      <div class="slider-container">
        <button class="arrow-button" id="prevBtn">←</button>
        <input id="sliceSlider" min="1" step="1" type="range" />
        <button class="arrow-button" id="nextBtn">→</button>
      </div>

      <div class="slice-info" id="sliceInfo">現在のスライス: 1</div>

      <div class="navigation">
        <button onclick="location.href='answer3-1.html'">
          <span class="icon">▶</span><span class="label">解答</span>
        </button>
      </div>
    </main>

    <!-- ===== フルスクリーン用ライトボックス ===== -->
    <div id="lightbox" class="lightbox" aria-hidden="true" role="dialog" aria-modal="true">
      <div class="lightbox-backdrop" id="lightboxBackdrop"></div>
      <div class="lightbox-content" role="document">
        <button id="closeFsBtn" class="lightbox-close" aria-label="閉じる">×</button>

        <div class="lightbox-viewer">
          <img alt="CT Slice (fullscreen)" id="ctImageFs" src="" />
        </div>

        <!-- スライダー（フルスクリーン用） -->
        <div class="slider-container slider-container-fs">
          <button class="arrow-button" id="prevBtnFs">←</button>
          <input id="sliceSliderFs" min="1" step="1" type="range" />
          <button class="arrow-button" id="nextBtnFs">→</button>
        </div>
      </div>
    </div>
    
    
    <script>
      /* ========== 元の状態管理 ========== */
      const imageSets = {
        Xp: { label: "レントゲン", totalSlices: 1, padding: 5 },
        "CT-tra": { label: "造影CT", totalSlices: 177, padding: 5 },
        "CT-lung": { label: "CT肺", totalSlices: 79, padding: 5 },
        "CT-cor": { label: "cor画像", totalSlices: 109, padding: 5 },
      };

      let currentSet = "Xp"; // ← 必要に応じて初期値を変更
      let currentSlice = 1;
      const imageCache = {};

      const ctImage = document.getElementById("ctImage");
      const slider = document.getElementById("sliceSlider");
      const info = document.getElementById("sliceInfo");
      const title = document.getElementById("setTitle");
      const loadingOverlay = document.getElementById("loadingOverlay");
      const mainContent = document.querySelector("main");
      const setButtonsContainer = document.getElementById("setButtonsContainer");

      function getImageFilename(n, set = currentSet) {
        const padding = imageSets[set].padding || 0;
        const padded = String(n).padStart(padding, "0");
        return `${set}/${set}-${padded}.JPG`;
      }

      function preloadImages(set, callback) {
        if (imageCache[set]) { callback(); return; }
        const { totalSlices } = imageSets[set];
        imageCache[set] = [];
        let loaded = 0;
        for (let i = 1; i <= totalSlices; i++) {
          const img = new Image();
          img.onload = img.onerror = () => {
            loaded++;
            if (loaded === totalSlices) callback();
          };
          img.src = getImageFilename(i, set);
          imageCache[set][i] = img;
        }
      }

      function applySliceToImgs(n){
        const img = imageCache[currentSet]?.[n];
        const src = img?.src || getImageFilename(n);
        ctImage.src = src;
        // FS側にも反映
        const fsImg = document.getElementById("ctImageFs");
        if (fsImg) fsImg.src = src;
      }

      function updateSlice(n) {
        const total = imageSets[currentSet].totalSlices;
        currentSlice = n;
        applySliceToImgs(n);
        info.textContent = `現在のスライス: ${n} / ${total}`;
        slider.value = n;
        // FSスライダーも同期
        const sliderFs = document.getElementById("sliceSliderFs");
        if (sliderFs) sliderFs.value = n;
      }

      function changeSlice(step) {
        const total = imageSets[currentSet].totalSlices;
        const newSlice = Math.max(1, Math.min(total, currentSlice + step));
        updateSlice(newSlice);
      }

      function switchImageSetTo(setName) {
        loadingOverlay.style.display = "flex";
        mainContent.style.display = "none";
        currentSet = setName;
        currentSlice = 1;

        slider.max = imageSets[setName].totalSlices;
        slider.value = currentSlice;

        // FS側スライダーのmaxも更新
        const sliderFs = document.getElementById("sliceSliderFs");
        if (sliderFs) sliderFs.max = imageSets[setName].totalSlices;

        preloadImages(currentSet, () => {
          loadingOverlay.style.display = "none";
          mainContent.style.display = "flex";
          updateSlice(currentSlice);
          updateButtonStates();
        });
      }

      function createSetButtons() {
        for (const key in imageSets) {
          const btn = document.createElement("button");
          btn.textContent = imageSets[key].label;
          btn.className = "set-button";
          btn.dataset.setKey = key;
          btn.addEventListener("click", () => switchImageSetTo(key));
          setButtonsContainer.appendChild(btn);
        }
      }

      function updateButtonStates() {
        const buttons = setButtonsContainer.querySelectorAll(".set-button");
        buttons.forEach((btn) => {
          const key = btn.dataset.setKey;
          if (key === currentSet) {
            btn.disabled = true;
            btn.innerHTML = `✔️ ${imageSets[key].label}`;
          } else {
            btn.disabled = false;
            btn.innerHTML = imageSets[key].label;
          }
        });
      }

      /* ========== ズーム & ドラッグ ========== */
      let zoomScale = 1;
      const MIN_ZOOM = 0.5;
      const MAX_ZOOM = 4;
      const STEP_ZOOM = 0.2;

      let offsetX = 0, offsetY = 0, startX = 0, startY = 0, isDragging = false;

      const zoomLevelEl = document.getElementById("zoomLevel");
      const zoomInBtn = document.getElementById("zoomInBtn");
      const zoomOutBtn = document.getElementById("zoomOutBtn");

      function applyZoom() {
        ctImage.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoomScale})`;
        zoomLevelEl.textContent = `${Math.round(zoomScale * 100)}%`;
      }

      function setZoom(next) {
        zoomScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, next));
        if (zoomScale <= 1) { offsetX = 0; offsetY = 0; }
        applyZoom();
      }
      function zoomIn() { setZoom(zoomScale + STEP_ZOOM); }
      function zoomOut() { setZoom(zoomScale - STEP_ZOOM); }
      function resetZoom() { zoomScale = 1; offsetX = 0; offsetY = 0; applyZoom(); }

      function clampOffsets() {
        const rect = document.querySelector(".viewer").getBoundingClientRect();
        const imgWidth = rect.width * zoomScale;
        const imgHeight = rect.height * zoomScale;
        const maxX = (imgWidth - rect.width) / 2;
        const maxY = (imgHeight - rect.height) / 2;
        offsetX = Math.max(-maxX, Math.min(maxX, offsetX));
        offsetY = Math.max(-maxY, Math.min(maxY, offsetY));
      }

      ctImage.addEventListener("mousedown", (e) => {
        if (zoomScale <= 1) return;
        e.preventDefault();
        isDragging = true;
        startX = e.clientX; startY = e.clientY;
        ctImage.style.cursor = "grabbing";
      });
      window.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const dx = e.clientX - startX, dy = e.clientY - startY;
        startX = e.clientX; startY = e.clientY;
        offsetX += dx; offsetY += dy;
        clampOffsets(); applyZoom();
      });
      window.addEventListener("mouseup", () => { isDragging = false; ctImage.style.cursor = "grab"; });

      // タッチ
      let lastTouchX = 0, lastTouchY = 0;
      ctImage.addEventListener("touchstart", (e) => {
        if (zoomScale <= 1) return;
        if (e.touches.length !== 1) return;
        const t = e.touches[0];
        lastTouchX = t.clientX; lastTouchY = t.clientY;
      });
      ctImage.addEventListener("touchmove", (e) => {
        if (zoomScale <= 1) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const t = e.touches[0];
        const dx = t.clientX - lastTouchX, dy = t.clientY - lastTouchY;
        lastTouchX = t.clientX; lastTouchY = t.clientY;
        offsetX += dx; offsetY += dy; clampOffsets(); applyZoom();
      });

      zoomInBtn.addEventListener("click", zoomIn);
      zoomOutBtn.addEventListener("click", zoomOut);

      // 画像セット切替時に倍率リセット
      const _origSwitchSet = switchImageSetTo;
      switchImageSetTo = function (setName) {
        _origSwitchSet(setName);
        resetZoom();
      };

      /* ========== スライダー操作（通常） ========== */
      document.getElementById("prevBtn").addEventListener("click", () => changeSlice(-1));
      document.getElementById("nextBtn").addEventListener("click", () => changeSlice(1));
      slider.addEventListener("input", (e) => updateSlice(parseInt(e.target.value, 10)));

      /* ========== フルスクリーン（ライトボックス） ========== */
      const lightbox = document.getElementById("lightbox");
      const backdrop = document.getElementById("lightboxBackdrop");
      const enterFsBtn = document.getElementById("enterFsBtn");
      const closeFsBtn = document.getElementById("closeFsBtn");
      const sliderFs = document.getElementById("sliceSliderFs");
      const prevBtnFs = document.getElementById("prevBtnFs");
      const nextBtnFs = document.getElementById("nextBtnFs");

      function openFullscreen() {
        // スライダーmax/値を同期
        sliderFs.max = imageSets[currentSet].totalSlices;
        sliderFs.value = currentSlice;
        applySliceToImgs(currentSlice);

        lightbox.classList.add("is-open");
        lightbox.setAttribute("aria-hidden", "false");
        document.body.style.overflow = "hidden"; // 背景スクロール抑止
        window.addEventListener("keydown", onKeydownEsc);
      }

      function closeFullscreen() {
        lightbox.classList.remove("is-open");
        lightbox.setAttribute("aria-hidden", "true");
        document.body.style.overflow = "";
        window.removeEventListener("keydown", onKeydownEsc);
      }

      function onKeydownEsc(e){
        if (e.key === "Escape") closeFullscreen();
      }

      enterFsBtn.addEventListener("click", openFullscreen);
      closeFsBtn.addEventListener("click", closeFullscreen);
      backdrop.addEventListener("click", closeFullscreen);

      // FS側の操作 → 状態共有
      prevBtnFs.addEventListener("click", () => changeSlice(-1));
      nextBtnFs.addEventListener("click", () => changeSlice(1));
      sliderFs.addEventListener("input", (e) => updateSlice(parseInt(e.target.value, 10)));

      /* ========== 初期表示 ========== */
      window.onload = () => {
        createSetButtons();
        updateButtonStates();
        preloadImages(currentSet, () => {
          loadingOverlay.style.display = "none";
          mainContent.style.display = "flex";
          updateSlice(currentSlice);
          applyZoom(); // 初期表示のズーム表示同期
        });
      };
    </script>
  </body>
</html>
